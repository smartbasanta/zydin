<script setup lang="ts">
    import { ref, computed, onMounted, watch, toRefs } from "vue";
    import InputError from "@/components/form/InputError.vue";
    import { RefreshCcw } from "lucide-vue-next";

    interface Props {
        modelValue?: string | null;
        sourceValue?: string | null;
        form?: Record<string, any>;
        sourceField?: string;
        targetField?: string;
        separator?: string;
        label?: string;
        hint?: string;
        error?: string | string[];
        showError?: boolean;
        maxLength?: number;
        disabled?: boolean;
        containerClass?: string | Record<string, boolean>;
        isDirty?: boolean;
        targetFieldLabel?: string;
        required?: boolean;
    }

    const props = withDefaults(defineProps<Props>(), {
        separator: "-",
        showError: true,
        disabled: false,
    });

    const emit = defineEmits(["update:modelValue"]);

    const inputRef = ref<HTMLInputElement | null>(null);
    const inputId = `slug-input-${Math.random().toString(36).slice(2)}`;
    const internalSeparator = ref(props.separator);
    const hasUserManuallyEdited = ref(false);
    const typingTimeout = ref<number | null>(null);
    const lastAutoGeneratedValue = ref<string | null>(null);

    const { modelValue, sourceValue, form, sourceField, targetField } =
        toRefs(props);

    const computedLabel = computed(
        () => props.label || props.targetFieldLabel || props.targetField || "Slug"
    );

    const escapeRegExp = (str: string): string =>
        str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

    const generateSlug = (
        input: string | null | undefined,
        sep: string
    ): string => {
        if (!input) return "";
        const safeSep = escapeRegExp(sep);
        return input
            .normalize("NFD")
            .replace(/[\u0300-\u036f]/g, "")
            .toLowerCase()
            .trim()
            .replace(/[^a-z0-9\s_.-]/g, "")
            .replace(/\s+/g, sep)
            .replace(new RegExp(`${safeSep}+`, "g"), sep)
            .replace(new RegExp(`^${safeSep}+|${safeSep}+$`, "g"), "");
    };

    const updateSlugModel = (newSlug: string) => {
        emit("update:modelValue", newSlug);
        if (form?.value && targetField?.value) {
            form.value[targetField.value] = newSlug;
        }
    };

    const syncSlug = () => {
        if (props.disabled || hasUserManuallyEdited.value) return;
        const source =
            sourceValue?.value ??
            (form?.value && sourceField?.value
                ? form.value[sourceField.value]
                : null);
        if (typeof source === "string") {
            const newGeneratedSlug = generateSlug(source, internalSeparator.value);
            updateSlugModel(newGeneratedSlug);
            lastAutoGeneratedValue.value = newGeneratedSlug;
        }
    };

    // Watch sourceValue or form[sourceField] for changes
    watch(
        () => [sourceValue?.value, form?.value?.[sourceField?.value ?? "name"]],
        () => {
            syncSlug();
        },
        { immediate: true }
    );

    // Watch modelValue to detect manual edits with typing timeout
    watch(modelValue, (currentSlug) => {
        if (props.disabled) return;

        const source =
            sourceValue?.value ??
            (form?.value && sourceField?.value
                ? form.value[sourceField.value]
                : null);
        const potentialAutoSlug = generateSlug(
            source ?? "",
            internalSeparator.value
        );

        if (typingTimeout.value) clearTimeout(typingTimeout.value);
        typingTimeout.value = window.setTimeout(() => {
            if (
                currentSlug !== potentialAutoSlug &&
                currentSlug !== lastAutoGeneratedValue.value
            ) {
                hasUserManuallyEdited.value = true;
            }
            if (currentSlug === potentialAutoSlug) {
                hasUserManuallyEdited.value = false;
                lastAutoGeneratedValue.value = currentSlug;
            }
            typingTimeout.value = null;
        }, 500);
    });

    const regenerateSlug = () => {
        if (props.disabled) return;
        const source =
            sourceValue?.value ??
            (form?.value && sourceField?.value
                ? form.value[sourceField.value]
                : null);
        if (source === null) return;
        const regenerated = generateSlug(source, internalSeparator.value);
        updateSlugModel(regenerated);
        hasUserManuallyEdited.value = false;
        lastAutoGeneratedValue.value = regenerated;
    };
    const changeSeparator = (sep: string) => {
        internalSeparator.value = sep;
        let source = sourceValue?.value; // Prioritize sourceValue

        if (!source && form?.value && sourceField?.value) {
            source = form.value[sourceField.value];
        }

        if (typeof source === 'string') {
            const newGeneratedSlug = generateSlug(source, internalSeparator.value);
            updateSlugModel(newGeneratedSlug);
            hasUserManuallyEdited.value = false;
            lastAutoGeneratedValue.value = newGeneratedSlug;
        }
    };

    // const changeSeparator = (sep: string) => {
    //     internalSeparator.value = sep;
    //     if (sourceValue?.value || (form?.value && sourceField?.value)) {
    //         const source =
    //             sourceValue?.value ?? form?.value[sourceField?.value ?? "name"];
    //         const newGeneratedSlug = generateSlug(
    //             source ?? "",
    //             internalSeparator.value
    //         );
    //         updateSlugModel(newGeneratedSlug);
    //         hasUserManuallyEdited.value = false;
    //         lastAutoGeneratedValue.value = newGeneratedSlug;
    //     }
    // };

    onMounted(() => {
        if (!props.disabled && inputRef.value?.hasAttribute("autofocus")) {
            setTimeout(() => {
                if (
                    !document.activeElement ||
                    document.activeElement === document.body
                ) {
                    inputRef.value?.focus();
                }
            }, 100);
        }
        syncSlug();
    });

    defineExpose({
        focus: () => {
            if (!props.disabled) {
                setTimeout(() => {
                    inputRef.value?.focus();
                }, 100);
            }
        },
        regenerate: regenerateSlug,
    });

    const availableSeparators = ["-", "_", ".", " ", "*"];
    const isSeparatorDropdownOpen = ref(false);
    const separatorDropdownRef = ref<HTMLElement | null>(null);
</script>

<template>
	<div class="flex flex-col gap-1" :class="props.containerClass">
		<div class="flex items-center justify-between mb-1">
			<label
				:for="inputId"
				class="label text-sm font-medium text-gray-700 dark:text-gray-300"
			>
				{{ computedLabel }}
                <span v-if="props.required" class="text-red-500 dark:text-red-400 ml-0.5">*</span>
			</label>
			<div class="relative" ref="separatorDropdownRef">
				<button
					type="button"
					@click="isSeparatorDropdownOpen = !isSeparatorDropdownOpen"
					class="btn btn-secondary"
					aria-haspopup="true"
					:aria-expanded="isSeparatorDropdownOpen"
					:disabled="props.disabled"
				>
					Separator:
					<span class="font-semibold mx-1">{{
						internalSeparator === " "
							? "[space]"
							: internalSeparator
					}}</span>
					<svg
						xmlns="http://www.w3.org/2000/svg"
						width="14"
						height="14"
						viewBox="0 0 24 24"
						fill="none"
						stroke="currentColor"
						stroke-width="2"
						stroke-linecap="round"
						stroke-linejoin="round"
					>
						<polyline points="6 9 12 15 18 9"></polyline>
					</svg>
				</button>
				<Transition
					enter-active-class="transition ease-out duration-100"
					enter-from-class="transform opacity-0 scale-95"
					enter-to-class="transform opacity-100 scale-100"
					leave-active-class="transition ease-in duration-75"
					leave-from-class="transform opacity-100 scale-100"
					leave-to-class="transform opacity-0 scale-95"
				>
					<div
						v-if="isSeparatorDropdownOpen"
						class="absolute right-0 mt-1 w-32 origin-top-right rounded-md menu-dropdown-panel z-10 py-1"
						role="menu"
						aria-orientation="vertical"
						aria-labelledby="separator-button"
					>
						<button
							v-for="sep in availableSeparators"
							:key="sep"
							type="button"
							class="w-full menu-dropdown-item"
							:class="{ active: sep === internalSeparator }"
							role="menuitem"
							@click="
								changeSeparator(sep);
								isSeparatorDropdownOpen = false;
							"
						>
							{{ sep === " " ? "[space]" : sep }}
						</button>
					</div>
				</Transition>
			</div>
		</div>

		<div class="relative">
			<div
				v-if="props.disabled"
				class="input bg-gray-100 dark:bg-gray-800 text-gray-500 dark:text-gray-400 cursor-not-allowed"
				:class="{ 'invalid-input': error }"
			>
				{{ modelValue }}
			</div>
			<input
				v-else
				:id="inputId"
				type="text"
				class="input w-full"
				:class="{
					'invalid-input': error,
					'dirty-input': isDirty,
					'pr-10': !props.disabled && hasUserManuallyEdited,
				}"
				:value="modelValue"
				@input="
					updateSlugModel(($event.target as HTMLInputElement).value)
				"
				ref="inputRef"
				:maxlength="props.maxLength"
				:disabled="props.disabled"
				placeholder="e.g., my-awesome-post"
			/>

			<button
				v-if="
					!props.disabled && hasUserManuallyEdited && !typingTimeout
				"
				type="button"
				class="absolute right-2 top-1/2 -translate-y-1/2 p-1 text-gray-500 hover:text-sky-500 dark:text-gray-400 dark:hover:text-sky-400 transition-colors"
				@click="regenerateSlug"
				title="Regenerate slug from source"
			>
				<RefreshCcw class="w-4 h-4" />
				<span class="sr-only">Regenerate slug</span>
			</button>

			<div
				v-if="props.maxLength"
				class="absolute -bottom-[19px] right-0 text-xs font-medium text-gray-500 dark:text-gray-400"
			>
				{{ (modelValue || "").length }}/{{ props.maxLength }}
			</div>
		</div>

		<p v-if="hint" class="text-xs mt-1 text-gray-500 dark:text-gray-400">
			{{ hint }}
		</p>
		<InputError v-if="error && showError" :error="error" />
	</div>
</template>
